https://github.com/boostcampwm2025/relay-note16

# 릴레이프로젝트 16

> 부스트캠프 커뮤니티 또는 개발자로서 학습과 성장을 위해 AI 활용하기

## 1️⃣ Slack 묻고 답하기 내역 요약

- 배경:
  Slack의 ‘묻고 답하기(Q&A)’ 채널은 유용하지만, 일부 사용자만 적극적으로 참여하고, 많은 사람들에게는 소통/공유가 잘 이뤄지지 않다.
  질문과 답변이 흘러가거나, 바쁜 사람, 비활성 유저는 놓치기 쉽다
  커뮤니티의 집단 지식, 정보 공유를 극대화하기 위해 Q&A 내용을 집약·알림할 필요가 있다.
- 기능:
  GPT 기반 Slack Q&A 요약 서비스
  1. 매일 새로 올라온 Q&A 채널에서 하루 동안 쌓인 질문·답변 메시지를 자동 수집하기
  2. AI가 요약 처리하기 : 중복이나 이미 해결된 이슈는 자동으로 Compact하게 처리
  3. 배포하기 : 다음 날 아침 슬랙/메일/웹 등으로 팀 채널로 자동 전달

## 2️⃣ AI에게 일정관리 맡기기

- 배경:
  미션을 수행하면서 학습과 구현, 휴식의 밸런스를 맞추는 것이 어렵다.
  누군가는 학습에 몰두하느라 구현이 어렵고, 누군가는 구현에 몰두하느라 학습이 어려워지는 경우가 있다.
  충분한 휴식을 취하지 못해 다음 날 미션에도 지장이 가는 경우가 있다.
- 기능:
  1. AI를 활용해 나에게 필요한 정보(오늘의 컨디션, 마감일, 미션 예상 시간, 학습 예상 시간, 코어타임, 체크리스트 등)을 바탕으로 프롬프트를 만들기
  2. AI에게 필요한 정보와 답변 형식, 일정 관리 형식을 넘겨주기
- 예시

  - **프롬프트 :** 미션 난이도는 이렇고 미션 학습 예상 시간은 8시간, 해결 예상시간은 8시간, 주제는 이건데, 미션 제출 마감은 내일 오전 9시이고, 미션은 오늘 오후 12시에 나와. 내 컨디션은 보통이야. 오늘의 일정을 추천해줘
  - **AI 답변:**

    ```
    # 오늘 일정 추천

    ---

    ## 상황 정리

    - **미션 난이도**: 이렇고 (구체적 내용 추가 가능)
    - **미션 학습 예상 시간**: 8시간
    - **미션 해결 예상 시간**: 8시간
    - **주제**: 이건데 (상세 내용 추가 가능)
    - **미션 배포 시각**: 오늘 오후 12시
    - **미션 제출 마감**: 내일 오전 9시
    - **컨디션**: 보통

    ---

    ## 일정 계획 (약 21시간 내 작업)

    ### 오늘 12:00 ~ 19:00 (코어타임, 7시간)

    - **12:00 ~ 12:30**
      미션 받고 전체 내용 빠르게 파악 및 계획 수립

    - **12:30 ~ 15:30 (3시간)**
      미션 학습 집중 (기본 개념 + 어려운 부분 위주)

    - **15:30 ~ 15:45 (휴식 15분)**

    - **15:45 ~ 18:30 (2시간 45분)**
      미션 해결 작업 시작 (코딩/구현 병행)

    - **18:30 ~ 19:00**
      당일 진행 상황 점검 및 내일 작업 계획 세우기

    ---

    ### 오늘 19:00 ~ 내일 6:30 (약 11시간 30분)

    - 휴식 및 가벼운 복습 또는 작업 지속 (컨디션에 따라 유동적)
    - 집중력 좋은 시간에 작업 최대한 진행
    - 적절히 휴식 챙기기

    ---

    ### 내일 6:30 ~ 9:00 (2시간 30분)

    - 미션 최종 점검, 디버깅, 테스트
    - 제출 전 문서화 및 마무리

    ---

    ## 팁

    - 미션 배포 직후 목표와 계획부터 확실히 세우기
    - 총 16시간(8+8) 중 7시간 이상은 오늘 코어타임에 집중하기
    - 컨디션에 따라 휴식 시간 꼭 챙기기
    - 여유 있게 마무리 일정 잡기

    ---

    필요하면 미션 상세 내용 알려줘!
    더 구체적으로 일정 조율 도와줄게 :)

    ```

  - 결과
    | 시간대 | 내용 | 비고 |
    | -------------------- | ---------------------------------- | ------------------------------ |
    | 12:00 ~ 12:30 | 미션 확인 및 전체 계획 수립 | 주제 파악, 학습/해결 전략 수립 |
    | 12:30 ~ 15:30 | 미션 학습 집중 | 기본 개념 + 심화 개념 |
    | 15:30 ~ 15:45 | 휴식 | 뇌 리프레시 타임 |
    | 15:45 ~ 18:30 | 미션 해결 작업 시작 (코딩/구현) | 중간에 추가 학습 병행 가능 |
    | 18:30 ~ 19:00 | 오늘 마무리 및 내일 작업 계획 정리 | 남은 작업 목록 작성 |
    | 19:00 ~ 00:00 (자율) | 학습/해결 지속 or 충분한 휴식 | 컨디션에 따라 유동적으로 |
    | 00:00 ~ 06:30 (자율) | 구현 마무리 + 디버깅 | 집중 가능한 시간대 활용 |
    | 06:30 ~ 09:00 | 최종 점검 및 제출 준비 | 테스트, 문서 정리 포함 |

  ***

## 3️⃣ 챌린지과정을 함께 헤쳐 나갈 AI리서치 파트너 만들기!

- 배경:
  과제를 해결하기 위해 무엇부터 공부해야 할지 막막하고 순서를 모르겠을 때가 많다.
  새로운 과제나 CS지식을 마주했을 때, 수많은 정보 속에서 어떤 자료부터 봐야 할지 선별하는 데 많은 시간을 쓰게 된다.
  무엇을, 어떤 순서로 공부해야 하는지에 대한 가이드가 필요하다.
- 기능:

  1. Ai한테 어떤 페르소나를 연기하도록 명령하기

     (ex. 너는 네이버에서 10년째 일하고 있는 시니어 개발자야. 신입 개발자에게 이 주제를 가르쳐준다고 생각하고 설명해줘)

  2. 과제의 주제나 특정 기술 키워드를 입력하면 해당 주제를 해결하는데 필요한 배경지식을 로드맵으로 추천해주도록 하는 프롬프트를 작성하기

## 4️⃣ `학습정리.md` 파일로부터 면접 질문 뽑아내기

- 배경:
  부스트캠프를 진행하며 작성한 `학습정리.md` 파일은 나만의 지식 저장소이다.
  하지만 그 내용을 얼마나 깊이 이해했는지 점검하기는 어렵다.
  실제로 추후 면접관이 그 내용을 물어본다면 대답하기 어려울 수 있다.
- 기능:
  1. 학습한 내용을 AI를 통해 면접 질문 형태로 바꿔주는 프롬프트를 작성하기
  2. 생성된 질문에 대해 답변을 직접 작성하기
  3. 생성된 질문에 대한 답변을 해달라는 프롬프트를 작성하고, 직접 작성한 답변과 비교하기
- 예시
  ```
  이것들은 내가 정리한 학습 내용이야. 이걸 바탕으로 면접관이 물어볼 만한 질문 N개를 만들어줘.
  가능하면 기초, 심화 수준을 섞어서
  ```
  ```
  이 내용에 대해 면접에서 나올 수 있는 질문을 만들어줘.
  그리고 내가 대답할 때 놓치기 쉬운 핵심 포인트도 알려줘.
  ```

# 퀘스트 선택

---

**J246\_정재민**

> `미션 선택` **학습정리.md 파일로부터 면접 질문 뽑아내기**

`선택 이유` 면접 cs 질문에 대한 막연한 공포심이 조금 존재해서, 이번 기회에 ai를 활용하여 면접 연습 느낌으로 진행해보려고 한다.

**J290\_홍민정**

> `미션 선택` **AI에게 일정관리 맡기기**

`선택 이유` 이번주 월요일부터 일정관리 실패로 밤새면서 한주 내내 좀비 상태로 과제를 진행했기 때문에, 다음 주차에는 AI에게 일정관리를 위임함으로써 일정관리 하는 법을 배워보고 싶어 선택하게 됐습니다.

**J265\_차지태**

> `미션 선택` **학습정리.md 파일로부터 면접 질문 뽑아내기**

`선택 이유` 그날 학습한 내용을 단순히 정리하는 데 그치지 않고 내가 얼마나 깊이 이해했는지를 점검하고 싶습니다

**K007\_김영대**

> `미션 선택` **학습정리.md 파일로부터 면접 질문 뽑아내기**

`선택 이유` 학습한 내용을 얼마나 이해했는지, 남들에게 설명할 수 있는지, 응용이 가능한지 등을 확인해보고 싶어 해당 퀘스트를 선택하였습니다.

# 퀘스트 진행

<details>
<summary>질문 내용</summary>

```
내가 정리한 학습 내용을 바탕으로 해당 주제에 대해서 면접 질문을 만들어줘
질문은 총 3단계로, 1단계는 개념 확인. 2단계는 확장(응용)된 개념 확인, 3단계는 구체적으로 이를 활용한 문제로 구성해줘

예를들면
1. Acticity의 개념
2. 안드로이드 4대 컴포넌트
3. Acticity와 관련한 실제 코드를 바탕으로 문제점 찾기 등

// 학습정리.md - 내용 생략
Day 09. 레이스 컨디션
- 스레드 레이스
- 비동기 이벤트 매니저
```

</details>

<br/>
AI 답변
<details>
<summary>Gemini</summary>

1. 프로세스, 스레드, 코루틴

- 1단계: 개념 확인

  - 프로세스와 스레드의 개념을 각각 설명하고, 이 둘의 가장 큰 차이점은 무엇인가요?
  - 코루틴(Coroutine)은 무엇이며, 스레드와 비교했을 때 어떤 장점을 가지고 있나요?

- 2단계: 확장/응용된 개념 확인

  - 멀티코어 CPU 환경에서 스레드 병렬 처리를 할 때 왜 레이스 컨디션을 고려해야 하는지 구체적인 예시와 함께 설명해 주세요.
  - 코루틴에서 Dispatchers.Main, Dispatchers.Default, Dispatchers.IO의 용도를 설명하고, 각각 어떤 종류의 작업에 적합한지 구체적인 사용 사례를 들어 설명해 주세요.

- 3단계: 구체적 활용 문제
  - 네트워크에서 데이터를 가져와서 UI를 업데이트해야 하는 상황이 있습니다. 이 작업을 코루틴으로 처리할 때, CoroutineScope와 launch를 사용하여 백그라운드 작업과 UI 작업이 올바른 Dispatcher에서 실행되도록 하는 예시 코드를 제시하고, 코드의 각 부분이 어떤 역할을 하는지 설명해 주세요.

2. 레이스 컨디션

- 1단계: 개념 확인

  - 레이스 컨디션(Race Condition)이 무엇인지 정의하고, 이러한 상황은 주로 어떤 조건에서 발생할 수 있나요?

- 2단계: 확장/응용된 개념 확인

  - 레이스 컨디션이 발생하기 위한 필수적인 조건에는 무엇이 있으며, 공유 자원(Shared Resource)의 역할은 무엇인지 설명해 주세요.

- 3단계: 구체적 활용 문제
  - 여러 스레드가 동시에 은행 계좌의 잔액을 조회하고 입금하는 상황을 가정해 봅시다. 이 상황에서 발생할 수 있는 레이스 컨디션 문제를 설명하고, 이를 해결하기 위한 구체적인 방법(예: synchronized 블록, lock, Mutex 등)을 제시해 보세요.

</details>

<details>
<summary>ChatGPT</summary>

면접 질문 세트 1: 코루틴과 스레드

1단계 – 개념 확인
코루틴과 스레드의 차이는 무엇인가요?

2단계 – 응용 개념 확인
코루틴의 Dispatcher를 선택할 때 기준은 무엇인가요? 각 Dispatcher의 특징을 설명해주세요.

3단계 – 실제 활용 문제
아래 코드에서 발생할 수 있는 문제는 무엇이며, 이를 어떻게 수정할 수 있을까요?

```kotlin
fun main() {
    GlobalScope.launch {
        delay(1000)
        println("비동기 작업 완료")
    }
    println("메인 함수 종료")
}
```

(힌트: 프로그램이 바로 종료되며 launch 내부가 실행되지 않을 수 있음)

<br/>

면접 질문 세트 2: 레이스 컨디션과 동기화

1단계 – 개념 확인
레이스 컨디션이란 무엇인가요? 언제 발생하나요?

2단계 – 응용 개념 확인
멀티스레딩 환경에서 레이스 컨디션을 방지하기 위한 방법에는 어떤 것들이 있나요?

3단계 – 실제 활용 문제
아래 코드에 레이스 컨디션 문제가 있다면, 어떻게 해결하시겠습니까?

```kotlin
var counter = 0

fun main() = runBlocking {
    repeat(1000) {
        launch {
            counter++
        }
    }
    println("Final Counter: $counter")
}
```

(힌트: counter++는 원자적 연산이 아님 – Mutex, AtomicInteger 등의 사용)

<br/>

면접 질문 세트 3: 이벤트 매니저와 Pub-Sub

1단계 – 개념 확인
Pub-Sub 패턴이란 무엇이며, Observer 패턴과 어떤 차이가 있나요?

2단계 – 응용 개념 확인
비동기 이벤트 매니저를 설계할 때 고려해야 할 요소는 무엇인가요? (예: 큐, 오류 처리, 병렬성 등)

3단계 – 실제 활용 문제
아래와 같은 상황에서 이벤트 누락이나 중복 처리를 방지하려면 어떻게 설계해야 할까요?

```kotlin
eventManager.postEvent(EventType.UPLOAD, sender = this, data = video)
```

(힌트: 큐에 이벤트를 한 번만 넣고, 구독자가 적절히 분산 처리되도록 하거나, 이벤트 상태 추적 로직 추가)

</details>

# J246\_정재민

📌 면접 질문 뽑아내기 (week11~14 기반)

1. 비동기 처리 & 이벤트 루프
   기초
   자바스크립트에서 비동기 처리가 필요한 이유는 무엇인가요?
   핵심 포인트: 싱글 스레드 특성, UI 블로킹 방지, 성능

setTimeout(() => console.log("A"), 0)와 Promise.resolve().then(() => console.log("B"))의 실행 순서가 어떻게 되고, 그 이유는 무엇인가요?
핵심 포인트: Microtask vs. Macrotask 우선순위

async/await는 내부적으로 어떤 방식으로 동작하나요?
핵심 포인트: Promise 기반, await는 Promise 완료까지 non-blocking 대기

심화
이벤트 루프(Event Loop)가 tick 단위로 동작한다는 것은 무슨 의미인가요? 실제 실행 순서를 예시 코드로 설명해 보세요.
핵심 포인트: script phase → microtask → macrotask 순환 구조, tick 개념

콜백 지옥(Callback Hell)이 발생하는 이유와 이를 해결할 수 있는 방법을 설명해 보세요.
핵심 포인트: 중첩 구조 문제, Promise / async-await / 함수 분리

Event Queue와 Call Stack의 관계를 설명하고, setTimeout이 “즉시” 실행되지 않는 이유를 구체적으로 말해보세요.
핵심 포인트: Web API 백그라운드 처리 → 큐 등록 → 이벤트 루프가 콜 스택이 빌 때 실행

2. 병렬 처리 & 스레드
   기초
   Node.js는 싱글 스레드 언어인데, CPU 연산 병렬화를 어떻게 지원하나요?
   핵심 포인트: worker_threads, 스레드풀 (libuv 기반 I/O 병렬)

스레드 풀(Thread Pool)이란 무엇이며, 왜 필요한가요?
핵심 포인트: 스레드 재사용으로 성능 최적화, Node.js I/O에 기본 4개 사용

심화
Node.js에서 Worker Threads와 Event Loop 기반 비동기의 차이를 설명하세요.
핵심 포인트: 비동기는 이벤트 루프 / I/O, 병렬은 CPU-bound 작업 분산

멀티 스레드 환경에서 레이스 컨디션(Race Condition)이 발생하는 원인과 해결 방법을 설명해 보세요.
핵심 포인트: 공유 자원 접근 동기화 필요 (Lock, Atomic 연산 등)

3. 객체지향 & 이벤트 기반 구조
   기초
   객체지향 설계(OOP)를 비동기 처리 로직에 적용했을 때 얻을 수 있는 장점은 무엇인가요?
   핵심 포인트: 유지보수성, 책임 분리, 재사용성

EventEmitter 패턴의 장단점을 설명해 보세요.
핵심 포인트: 느슨한 결합과 유연성, 그러나 디버깅/복잡성 문제

심화
이벤트 기반 아키텍처(Event-driven architecture)를 사용했을 때, 디버깅이 어려운 이유는 무엇인가요? 해결책을 제시해 보세요.
핵심 포인트: 이벤트 흐름 추적 어려움 → 로깅/모니터링/구조적 이벤트 네이밍 활용

4. Git Internals (week13~14)
   기초
   Git에서 blob, tree, commit, tag object의 차이점을 설명하세요.
   핵심 포인트: 파일 내용(blob), 디렉토리 구조(tree), 프로젝트 상태(commit), 레이블(tag)

Git object가 .git/objects 폴더에 저장될 때 어떤 방식으로 저장되나요?
핵심 포인트: <type> <size>\0<content> 구조, zlib 압축, SHA-1 해시 기반

심화
Git이 echo "hello world" > a.txt 후 git add 했을 때 내부적으로 어떤 과정을 거쳐 object가 생성되는지 단계별로 설명해 보세요.
핵심 포인트: blob 생성 → 헤더+내용 해시 계산 → 압축 저장 → index에 기록

SHA-1 대신 커스텀 해시 함수를 쓰면 Git 호환성이 어떻게 깨질 수 있나요?
핵심 포인트: object ID 일관성 상실, 네트워크/리모트 호환 불가, 단일 환경에서는 가능

📌 활용 방법
질문 생성 프롬프트

plaintext
복사
편집
이것은 내가 정리한 학습 내용이야. 면접관이 물어볼 만한 질문 10개를 만들어줘.
기초, 심화 수준을 섞어서 제시해주고, 내가 대답할 때 놓치기 쉬운 핵심 포인트도 알려줘.
답변 작성 후 비교 프롬프트

plaintext
복사
편집
이 질문에 내가 직접 작성한 답변은 다음과 같아.  
AI가 이상적인 답변을 작성해주고, 내 답변과 비교해서 부족한 점을 알려줘.

# J265\_차지태

📌 단순히 면접 질문만 뽑아냈을때

<aside>
💡

면접관의 의도와 함께 면접 질문에 대한 생각만 진행

</aside>

### ✅ 1. 비동기 처리 문법

1. **JavaScript에서 비동기 처리란 무엇인가요?**
   - → 비동기와 동기 개념의 차이를 알고 있는지
2. **콜백 함수 방식의 단점은 무엇이며, 이를 어떻게 보완할 수 있나요?**
   - → 콜백 헬과 그 해결 방식(Promise, async/await)의 이해
3. **Promise의 상태(pending, fulfilled, rejected)는 언제 어떻게 변하나요?**
   - → Promise 객체의 생명주기 이해
4. **async/await는 내부적으로 어떻게 동작하나요? 어떤 상황에서 사용하는 것이 적절할까요?**
   - → Promise 기반으로 작동한다는 점, 동기적 코드 표현의 이점 설명
5. **Promise.all()과 Promise.race()의 차이를 설명해 주세요.**
   - → 병렬 실행 흐름의 정확한 이해

### ✅ 2. 이벤트 루프와 큐

1. **이벤트 루프란 무엇이며, JavaScript에서 어떤 역할을 하나요?**
   - → 싱글 스레드 환경에서 비동기 처리를 어떻게 관리하는지
2. **setTimeout 콜백은 언제 실행되나요?**
   - → 이벤트 큐에 등록되고, 콜스택이 비는 순간 실행됨을 설명할 수 있는지
3. **Microtask Queue와 Event Queue의 차이는 무엇인가요?**
   - → `Promise.then()`과 `setTimeout()`의 실행 순서 차이 설명 가능 여부

📌 면접 질문 뽑아내기

<aside>
💡

- **내가 면접 질문 제시**
- **당신이 응답**
- **내가 어투, 구조, 내용 측면에서 코칭 및 피드백 제공**
</aside>

### ❓면접 질문 1

**Git에서 `commit` 명령어는 내부적으로 어떤 동작을 하나요? `commit`을 실행하면 어떤 객체들이 생성되고, 그 흐름은 어떻게 되나요?**

나의 답변

> 커밋 명령어은 스테이징 영역에 있는 변경 사항을 로컬 저장소에 저장하는 단계로 알고 있습니다
> 커밋 명령이 실행될때 트리객체와 커밋 객체가 생성되며 깃 안에 인덱스 폴더 내용으로 트리 객체를 생성하고 이 트리 객체와 메타정보가 합쳐져 커밋 객체를 생성하고 오브젝트라는 곳에 커밋 객체가 저장되는 것으로 알고 있습니다

AI 코칭

> ### ✅ 1. **내용 측면 피드백 (정확성 및 보완 포인트)**
>
> - **강점**
>   - `스테이징 영역` → `트리 객체` → `커밋 객체` → `.git/objects` 저장까지 전체 흐름을 이해하고 있어요.
>   - `트리 객체는 인덱스를 기반으로 만들어진다`는 말도 핵심을 잘 짚었습니다.
> - **보완할 점**
>   - **Blob 객체 생성과정이 빠졌어요.**
>     실제로 `commit` 전에 `add`로 blob이 생성되고, `commit` 시점에는 blob들을 참조하는 tree → commit 구조가 저장됩니다.
>   - **커밋 객체에 포함되는 메타정보를 구체적으로 말해주면 좋아요.**
>     예: author, timestamp, commit message, parent 커밋 등
>   - **`.git/index`는 '폴더'가 아니라 '파일'이에요.**
>     "인덱스 폴더 내용" → "인덱스 파일에 저장된 내용"으로 표현하면 정확합니다.
>
> ---
>
> ### 🗣 2. **말하는 어투 및 표현 코칭**
>
> - 개선 전:
>   > "커밋 명령어은 스테이징 영역에 있는 변경 사항을 로컬 저장소에 저장하는 단계로 알고 있습니다"
> - 개선 후:
>   > "Git에서 commit 명령어는 스테이징 영역(index)에 있는 내용을 기반으로 새로운 커밋 객체를 생성해 로컬 저장소에 저장하는 과정입니다"
> - 조언:
>   - "저장된다", "하는 것으로 알고 있습니다" → 단정적인 어투로 말하는 게 면접에서는 더 신뢰감을 줍니다.
>   - “하는 것으로 알고 있습니다”보다는 “~입니다”, “~로 구성됩니다”처럼 자신감 있게 말해주세요.
>
> ---
>
> ### 🧠 3. **전체적으로 더 좋은 답변 구조 예시**
>
> > Git에서 commit 명령어는 스테이징 영역(index)에 있는 스냅샷을 기반으로 커밋을 생성하는 명령입니다.
> >
> > 내부적으로는 먼저 index 파일의 정보로부터 트리(Tree) 객체가 생성됩니다. 이 트리 객체는 각각의 파일을 가리키는 blob 객체들을 참조합니다.
> >
> > 이후 author, timestamp, 커밋 메시지, parent 커밋 해시 등의 메타정보와 함께 커밋 객체가 생성되고, 이 객체는 `.git/objects` 디렉토리에 저장됩니다.
> >
> > 커밋은 Git의 핵심 단위로, 히스토리 관리와 버전 비교의 기준점이 됩니다.

### ❓면접 질문 2

**Git에서 `add` 명령어는 내부적으로 어떤 객체를 만들며, index에는 어떤 정보가 저장되나요?**

나의 답변

> 해당 명령어는 워킹 디렉터리에서 수정된 파일을 스테이징 영역에 옮기는 명령어이며
> 깃은 파일을 읽고 해시를 계산해 객체로 만들어 오브젝트 디렉터리에 blob 객체로 저장합니다

AI 코칭

> ## ✅ 1. **내용 피드백 (정확성 및 보완)**
>
> - **강점**
>   - `add` 시점에 Git이 파일을 읽고 해시를 계산하여 blob 객체를 생성한다는 설명이 정확합니다.
>   - 오브젝트 디렉터리에 저장된다는 부분도 명확히 짚었어요.
> - **보완할 점**
>   - \*Index(index file)\*\*에 대한 언급이 부족합니다.
>     → `add`는 단순히 blob을 저장하는 것에서 끝나는 것이 아니라, blob의 **해시, 파일 경로, 권한, 타임스탬프 등 메타정보를 index에 등록**하는 것이 핵심입니다.
>   - **변경되지 않은 파일은 blob으로 재생성하지 않음**을 부가로 언급하면 더 심화된 답변이 됩니다.
>     → 해시가 동일하면 객체를 재사용합니다 (Git의 저장 효율 핵심 포인트).
>
> ---
>
> ## 🗣 2. **말하는 방식 및 어투 개선 제안**
>
> - 개선 전:
>   > 해당 명령어는 워킹 디렉터리에서 수정된 파일을 스테이징 영역에 옮기는 명령어이며
>   >
>   > 깃은 파일을 읽고 해시를 계산해 객체로 만들어 오브젝트 디렉터리에 blob 객체로 저장합니다
> - 개선 후:
>   > Git의 add 명령어는 워킹 디렉터리에서 수정된 파일을 스테이징 영역(index)에 등록하는 과정입니다.
>   >
>   > 이때 Git은 해당 파일의 내용을 읽고 SHA-1 해시를 계산한 뒤, 이를 blob 객체로 만들어 `.git/objects` 디렉터리에 저장합니다.
>   >
>   > 동시에 index 파일에는 해당 blob의 해시, 파일 경로, 권한 등의 메타정보가 기록됩니다.
> - 코칭 포인트:
>   - “~하는 명령어이며” → 문장을 잘라서 나눠주는 것이 좋습니다.
>   - “깃은 ~ 합니다” → “Git은 ~ 합니다”로 고유명사는 정확히 발음.
>   - 기술 면접에서는 가능하면 **전문 용어(index, blob, SHA-1 등)**를 **자연스럽게 끼워넣는 연습**이 좋습니다.
>
> ---
>
> ## 🧠 정리 예시 (면접에서 말하면 좋은 포맷)
>
> > Git의 add 명령어는 워킹 디렉터리에서 수정된 파일을 스테이징 영역(index)에 등록하는 과정입니다.
> >
> > 이때 Git은 해당 파일의 내용을 읽어 SHA-1 해시를 계산한 뒤, 이를 blob 객체로 만들어 `.git/objects` 디렉터리에 저장합니다.
> >
> > 그리고 index에는 이 blob 객체의 해시, 파일 경로, 권한, 타임스탬프 같은 메타정보가 함께 기록됩니다.
> >
> > 이후 `commit` 명령어가 실행될 때, 이 index 정보를 기반으로 tree와 commit 객체가 생성됩니다.

### ❓면접 질문 3

**Git에서 `HEAD`는 무엇을 의미하나요? `HEAD`가 가리키는 위치가 바뀐다는 말은 무슨 뜻인가요?**

나의 답변

> 깃의 헤드란 체크아웃된 브랜치의 최신 커밋을 가리키며 위치가 바뀐다는 뜻은 작업중인 커밋이 바뀌었다를 나타냅니다.

AI 코칭

> ## ✅ 1. **내용 피드백: 정확성과 보완 포인트**
>
> - **강점**
>   - `HEAD`는 "체크아웃된 브랜치의 최신 커밋을 가리킨다" → 아주 정확한 표현입니다.
>   - "위치가 바뀐다는 건 작업 중인 커밋이 바뀐 것" → 개념적으로도 맞습니다.
> - **보완 포인트**
>   - `HEAD`가 **포인터**이며, 일반적으로는 브랜치를 가리키고, detached 상태에서는 직접 커밋을 가리킨다는 점도 말하면 심화된 답변이 됩니다.
>   - 브랜치를 `checkout` 하면 `HEAD`가 해당 브랜치를 가리키도록 이동하고,
>     detached HEAD 상태에서는 특정 커밋을 직접 가리키는 점까지 설명하면 좋습니다.
>
> ---
>
> ## 🗣 2. **어투 및 표현 코칭**
>
> - 개선 전:
>   > "깃의 헤드란 체크아웃된 브랜치의 최신 커밋을 가리키며 위치가 바뀐다는 뜻은 작업중인 커밋이 바뀌었다를 나타냅니다."
> - 개선 후:
>   > "HEAD는 현재 체크아웃된 브랜치를 가리키는 포인터이며, 해당 브랜치의 최신 커밋을 추적합니다.
>   >
>   > `HEAD`의 위치가 바뀐다는 건, 작업 기준이 되는 커밋이 변경되었음을 의미하며, 예를 들어 다른 브랜치를 체크아웃하거나, 특정 커밋으로 이동한 경우입니다."
> - 코칭 포인트:
>   - ‘~라는 뜻입니다’보다 → ‘즉’, ‘예를 들어’ 같은 **말의 전환을 넣어 흐름을 자연스럽게** 해보세요.
>   - ‘작업 중인 커밋’은 `기준 커밋`, `현재 커밋`이라고 말하는 것이 더 중립적이고 정확한 어투입니다.
>
> ---
>
> ## 🧠 전체적으로 좋은 답변 예시 (조리 있게 구조화)
>
> > Git에서 HEAD는 현재 작업 중인 위치를 가리키는 포인터입니다.
> >
> > 일반적으로는 체크아웃된 브랜치를 가리키며, 해당 브랜치의 최신 커밋을 추적합니다.
> >
> > `HEAD`의 위치가 바뀐다는 것은, 즉 작업 기준이 되는 커밋이 바뀌었다는 뜻입니다.
> >
> > 예를 들어 브랜치를 전환(`checkout`)하거나 특정 커밋으로 직접 이동하면 `HEAD`가 새로운 위치를 가리키게 됩니다.
> >
> > 이때 후자의 경우는 detached HEAD 상태라고 부릅니다.

<aside>
💡

느낀점

- 맨 처음은 단순히 AI가 면접관이 되어서 질문과 면접관이 원하는 핵심 평가 포인트만 집어주도록 했다. 하지만 이는 다소 생각하는 것에 그쳐서 현실감각을 익히는 것에는 어려움이 든다고 판단했고 이후부터는 AI의 역할을 확장 시켜 면접관이 되고 또한 나의 대답에 대한 AI 코칭을 해주는 방식으로 진행했다 이 방법이 좀더 나에게 학습하는 관점에서는 도움을 줬고 기존에 나의 생각을 전달하는 방식에 있어서 다소 부족한 점을 메울 수 있는 방식이라고 생각했다 실제로 말하는 것처럼 내가 생각하고 말하면서 답변을 작성했고 이를 프롬프트에 전달해서 실제 면접인것처럼 진행했더니 어투와 전달하는 방식에 있어서 개선에 도움이 되었다.
</aside>

---

# J290 홍민정

## 미션 선택

AI에게 일정 관리를 맡기는 미션을 선택했습니다.<br>결론부터 말하자면 크게 도움이 되지 않았습니다.

대개 시간 단위로 다음으로 넘어갈 수 있는 주제가 아니라<br>해당 기능을 구현 못하면 다음 기능으로 이어지지 않는 구조이다보니 항상 시간이 오바되었기 때문입니다.

### Day11-12 일정 관리

#### Day11 일정 추천

| 시간          | 활동 내용                                            |
| ------------- | ---------------------------------------------------- |
| 09:00 - 09:30 | 오늘 미션 개요 정독 및 전체 흐름 파악                |
| 09:30 - 11:30 | 객체지향 설계 및 비동기 이벤트 개념 학습 (1/2)       |
| 11:30 - 12:30 | 병렬 처리 구조 학습 및 적용 방식 정리 (2/2)          |
| 12:30 - 13:30 | 점심 및 휴식                                         |
| 13:30 - 15:30 | 전체 시스템 설계: 모듈/Queue/이벤트 루프 구조 도식화 |
| 15:30 - 17:30 | 등록 모듈 및 이벤트 루퍼 구현 시작                   |
| 17:30 - 18:30 | 저녁 식사 및 휴식                                    |
| 18:30 - 20:30 | 변환/검증/현황판 모듈 구현                           |
| 20:30 - 21:30 | 출력 포맷 정리 및 gist 커밋 작성                     |
| 21:30 - 22:00 | 자가 피드백 및 보완 포인트 체크                      |

어느정도 도메인 지식이 생긴 현재 시점에서는<br>정말 좋은 계획표였지만 처음 답변을 받은 시점에서는<br>조금 촉박한 일정이었다고 생각합니다.

리팩토링을 전혀 고려하지 않았다면 가능했을 일정 같습니다.

#### Day12 일정 추천

| 시간          | 활동 내용                                 |
| ------------- | ----------------------------------------- |
| 09:00 - 09:30 | 전날 코드 복습 및 개선할 타입 탐색        |
| 09:30 - 10:30 | 타입 개선 목록 정리 및 테스트 계획 수립   |
| 10:30 - 12:00 | 개선할 로직 리팩토링 (의존성 최소화 고려) |
| 12:00 - 13:00 | 점심 및 가벼운 산책                       |
| 13:00 - 15:00 | Jest 또는 Mocha 기반 단위 테스트 작성     |
| 15:00 - 16:00 | 테스트 스위트 정리 및 리팩토링 구조 검토  |
| 16:00 - 17:00 | 전체 리뷰 및 커밋 정리                    |

일단 저의 단위테스트는 도저히 2시간에 끝날 분량이 아니었습니다.<br>하지만, 리팩토링을 최소화하고 2일차에 몰아하는 유형이라면 유의미한 전략 같습니다.

Day11에 리팩토링을 함께 진행했기 때문에 조금 무리인 전략이었습니다.

### Day13-14 일정 관리

#### Day13 일정 추천

| 시간          | 활동 내용                                                      |
| ------------- | -------------------------------------------------------------- |
| 09:00 - 09:30 | git 구조 및 object 저장 방식 학습 (blob/tree/commit) 개요 파악 |
| 09:30 - 11:30 | 짝과 git 명령 분담 및 init/add/commit 구조 설계                |
| 11:30 - 12:30 | `init`, `add` 명령 구현 및 .git 내부 구조 분석 도구 작성       |
| 12:30 - 13:30 | 점심 및 휴식                                                   |
| 13:30 - 15:00 | `commit` 구현 및 object 디렉토리 구조 반영                     |
| 15:00 - 17:00 | `log`, `status` 구현 및 sha256/zlib 활용                       |
| 17:00 - 18:00 | 커밋 기록 추적기(log/parser) 작성 및 짝 리뷰                   |
| 18:00 - 18:30 | 전체 기능 테스트 및 git 명령과 비교                            |

추상화나 설계에 시간을 안 들였다면 가능한 시간 타임인 것 같습니다.<br>
하지만 금주에는 설계에 대한 욕심이 가득했기 때문에 적용이 쉽지 않았습니다.

솔직히, init과 add를 구현한 시점에서 코어타임이 지나가있었습니다.<br>다만 나만의 체크포인트라던가 그런 순서 측면에서 도움 받기 좋다고 생각합니다.

#### Day14 일정 추천

| 시간          | 활동 내용                                                         |
| ------------- | ----------------------------------------------------------------- |
| 09:00 - 09:30 | 전날 작성한 git object 구조 정리 및 개선 아이디어 회의            |
| 09:30 - 11:00 | `git clone` 역할을 대체하는 명령어 설계 및 object write 구조 확장 |
| 11:00 - 12:00 | 객체 생성 로직 정리 및 기존 기능과 병합                           |
| 12:00 - 13:00 | 점심 및 휴식                                                      |
| 13:00 - 14:30 | 나만의 해시 함수 구현 및 테스트 코드 작성                         |
| 14:30 - 15:30 | 단위 테스트 구성 및 패키지 단위 리팩토링                          |
| 15:30 - 16:30 | 커버리지 점검 및 git 공식 명령과 결과 비교                        |

항상 전날 버그 포인트를 짜고나면 코어타임이 다 지나가있어서<br>이번 주에는 미션에 적응하지 못했지만 다음 주에는 적용해보려고 합니다.

구현 욕심을 좀 내려놓으면 괜찮은 계획이라고 생각했습니다.<br>
현재의 제가 적용하기엔 리팩토링 시간이 현저히 적다고 느꼈지만,<br>구현 목적이면 괜찮은 것 같습니다.
